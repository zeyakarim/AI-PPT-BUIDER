import PptxGenJS from 'pptxgenjs';
import { Presentation } from '../types/ppt';
import type { TextProps, TextPropsOptions } from 'pptxgenjs';

function bulletLine(text: string, indent: number = 0): TextProps {
  const opts: TextPropsOptions = {
    bullet: { type: 'bullet', code: '2022' }, 
    indentLevel: indent,
    fontSize: 18,
    lineSpacing: 28,
    color: '363636',
  };
  return { text: text.trim(), options: opts };
}

export function generatePptx(presentationData: Presentation): PptxGenJS {
  const pptx = new PptxGenJS({ layout: 'LAYOUT_WIDE' });
  pptx.title = presentationData.title;

  const titleSlide = pptx.addSlide();
  titleSlide.addText(presentationData.title, {
    x: 0.5,
    y: 1.8,
    w: '90%',
    h: 1.2,
    fontSize: 44,
    bold: true,
    align: 'center',
    color: '363636',
  });
  titleSlide.addText('Generated by AI', {
    x: 0,
    y: 3.4,
    w: '100%',
    h: 0.6,
    fontSize: 24,
    align: 'center',
    color: '666666',
  });

  presentationData.slides.forEach((slide) => {
    const s = pptx.addSlide({ masterName: 'BLANK' });
    s.addText(slide.title, {
      x: 0.5,
      y: 0.3,
      w: '90%',
      h: 0.6,
      fontSize: 32,
      bold: true,
      color: '2F5496',
    });

    let raw = Array.isArray(slide.content) ? slide.content : [slide.content];
    let finalContentArray: string[] = [];

    raw.forEach(contentBlock => {
        if (typeof contentBlock === 'string' && contentBlock.match(/[.?!]/)) {
            const splitLines = contentBlock
                .split(/([.?!])\s+/) 
                .map((part, index, arr) => {
                    if (index > 0 && part.length === 1 && part.match(/[.?!]/)) {
                        arr[index - 1] = (arr[index - 1] || '') + part;
                        return null;
                    }
                    return part;
                })
                .filter(Boolean)
                .map(line => line?.trim())
                .filter(line => line?.length > 0);
                
            finalContentArray.push(...splitLines);
            
        } else if (contentBlock.trim().length > 0) {
            finalContentArray.push(contentBlock.trim());
        }
    });
    
    if (finalContentArray.length === 0 && raw.length > 0) {
        finalContentArray = raw.filter(l => l.trim().length > 0).map(l => l.trim());
    }
    const bulletProps: TextProps[] = finalContentArray.map((line) => bulletLine(line, 1)); 

    s.addText(bulletProps, {
      x: 0.6,
      y: 1.1,
      w: '88%',
      h: 5.5,
      align: 'left',
      valign: 'top',
    });
  });

  return pptx;
}

export function downloadPptx(pptx: PptxGenJS, filename = 'presentation.pptx') {
  pptx.writeFile({ fileName: filename });
}